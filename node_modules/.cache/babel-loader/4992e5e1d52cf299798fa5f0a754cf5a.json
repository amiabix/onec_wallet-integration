{"ast":null,"code":"import WalletConnect from '@walletconnect/client';\nimport deepmerge from 'deepmerge';\nimport { KeyValueStorage } from 'keyvaluestorage';\nimport * as React from 'react';\nimport { Linking, Platform } from 'react-native';\nimport useDeepCompareEffect from 'use-deep-compare-effect';\nimport { defaultRenderQrcodeModal, formatWalletServiceUrl } from '../constants';\nimport { WalletConnectContext } from '../contexts';\nimport { useMobileRegistry, useWalletConnectContext } from '../hooks';\nimport { ConnectorEvents } from '../types';\nconst defaultState = Object.freeze({\n  visible: false\n});\nexport default function WalletConnectProvider(_ref) {\n  let {\n    children,\n    renderQrcodeModal: maybeRenderQrcodeModal,\n    ...extras\n  } = _ref;\n  const {\n    error: walletServicesError,\n    data: walletServices\n  } = useMobileRegistry();\n  const [state, setState] = React.useState(defaultState);\n  const parentContext = useWalletConnectContext();\n  const intermediateValue = React.useMemo(() => deepmerge(parentContext, extras), [parentContext, extras]);\n  const renderQrcodeModal = React.useMemo(() => typeof maybeRenderQrcodeModal === 'function' ? maybeRenderQrcodeModal : defaultRenderQrcodeModal, [maybeRenderQrcodeModal]);\n  const open = React.useCallback(async (uri, cb) => {\n    if (Platform.OS === 'android') {\n      const canOpenURL = await Linking.canOpenURL(uri);\n\n      if (!canOpenURL) {\n        Linking.openURL('https://walletconnect.org/wallets');\n        throw new Error('No wallets found.');\n      }\n\n      await Linking.openURL(uri);\n    }\n\n    setState({\n      uri,\n      visible: true,\n      cb\n    });\n    return undefined;\n  }, [setState]);\n  const close = React.useCallback(() => {\n    setState(currentState => {\n      const {\n        cb\n      } = currentState;\n      setTimeout(() => typeof cb === 'function' && cb(), 0);\n      return {\n        uri: undefined,\n        visible: false,\n        cb: undefined\n      };\n    });\n    return undefined;\n  }, [setState]);\n  const qrcodeModal = React.useMemo(() => ({\n    open,\n    close\n  }), [open, close]);\n  const {\n    storageOptions,\n    redirectUrl\n  } = intermediateValue;\n  const createStorage = React.useCallback(storageOptions => {\n    return new KeyValueStorage(storageOptions);\n  }, []);\n  const [storage, setStorage] = React.useState(() => createStorage(storageOptions));\n  useDeepCompareEffect(() => {\n    setStorage(createStorage(storageOptions));\n  }, [setStorage, storageOptions]);\n  const sessionStorageKey = React.useMemo(() => `${storageOptions.rootStorageKey}:session`, [storageOptions]);\n  const walletServiceStorageKey = React.useMemo(() => `${storageOptions.rootStorageKey}:walletService`, [storageOptions]);\n  const connectToWalletService = React.useCallback(async (walletService, uri) => {\n    if (typeof uri !== 'string' || !uri.length) {\n      return Promise.reject(new Error('Invalid uri.'));\n    }\n\n    const maybeRedirectUrl = typeof redirectUrl === \"string\" ? `&redirectUrl=${encodeURIComponent(redirectUrl)}` : \"\";\n    const connectionUrl = `${formatWalletServiceUrl(walletService)}/wc?uri=${encodeURIComponent(uri)}${maybeRedirectUrl}`;\n\n    if (await Linking.canOpenURL(connectionUrl)) {\n      return (await Promise.all([storage.setItem(walletServiceStorageKey, walletService), Linking.openURL(connectionUrl)])) && undefined;\n    }\n\n    return Promise.reject(new Error('Unable to open url.'));\n  }, [walletServiceStorageKey, storage, redirectUrl, state]);\n  const [connector, setConnector] = React.useState();\n  const createConnector = React.useCallback(async function shouldCreateConnector(params) {\n    const {\n      storageOptions: _storageOptions,\n      ...extras\n    } = params;\n    const [maybeExistingSession, maybeExistingWalletService] = await Promise.all([await storage.getItem(sessionStorageKey), await storage.getItem(walletServiceStorageKey)]);\n    const isResumable = !!maybeExistingSession && (Platform.OS === 'android' || !!maybeExistingWalletService);\n\n    if (!isResumable) {\n      await Promise.all([storage.removeItem(sessionStorageKey), storage.removeItem(walletServiceStorageKey)]);\n    }\n\n    const nextConnector = new WalletConnect({\n      session: isResumable ? maybeExistingSession : undefined,\n      qrcodeModal,\n      ...extras\n    });\n\n    const maybeThrowError = error => {\n      if (error) {\n        throw error;\n      }\n    };\n\n    nextConnector.on(ConnectorEvents.CONNECT, async error => {\n      maybeThrowError(error);\n      await storage.setItem(sessionStorageKey, nextConnector.session);\n    });\n    nextConnector.on(ConnectorEvents.CALL_REQUEST_SENT, async error => {\n      maybeThrowError(error);\n\n      if (Platform.OS === 'android') {\n        const {\n          peerMeta\n        } = nextConnector;\n\n        if (!!peerMeta && typeof peerMeta === 'object') {\n          const [maybeShortName] = `${peerMeta.name || ''}`.toLowerCase().split(/\\s+/);\n\n          if (typeof maybeShortName === 'string' && !!maybeShortName.length) {\n            const {\n              walletServices\n            } = parentContext;\n            const [...maybeMatchingServices] = (walletServices || []).filter(_ref2 => {\n              let {\n                metadata: {\n                  shortName\n                }\n              } = _ref2;\n              return `${shortName}`.toLowerCase() === maybeShortName;\n            });\n\n            if (maybeMatchingServices.length === 1) {\n              const [detectedWalletService] = maybeMatchingServices;\n              const url = formatWalletServiceUrl(detectedWalletService);\n\n              if (await Linking.canOpenURL(url)) {\n                return Linking.openURL(url);\n              }\n            }\n          }\n        }\n\n        Linking.openURL('wc:');\n      } else if (Platform.OS !== 'web') {\n        const walletService = await storage.getItem(walletServiceStorageKey);\n\n        if (!walletService) {\n          return maybeThrowError(new Error('Cached WalletService not found.'));\n        }\n\n        const url = formatWalletServiceUrl(walletService);\n        return (await Linking.canOpenURL(url)) && Linking.openURL(url);\n      }\n    });\n    nextConnector.on(ConnectorEvents.SESSION_UPDATE, async error => {\n      maybeThrowError(error);\n      await storage.setItem(sessionStorageKey, nextConnector.session);\n    });\n    nextConnector.on(ConnectorEvents.DISCONNECT, async error => {\n      await Promise.all([storage.setItem(sessionStorageKey, undefined), storage.setItem(walletServiceStorageKey, undefined)]);\n      setConnector(await shouldCreateConnector(params));\n      maybeThrowError(error);\n    });\n    return nextConnector;\n  }, [sessionStorageKey, walletServiceStorageKey, storage, qrcodeModal, setConnector, parentContext]);\n  useDeepCompareEffect(() => {\n    (async () => {\n      setConnector(await createConnector(intermediateValue));\n    })();\n  }, [setConnector, createConnector, intermediateValue]);\n  const onDismiss = React.useCallback(() => {\n    close();\n\n    (async () => {\n      setConnector(await createConnector(intermediateValue));\n    })();\n  }, [close, setConnector, createConnector, intermediateValue]);\n  const modalProps = React.useMemo(() => ({\n    connectToWalletService,\n    visible: state.visible,\n    walletServices,\n    uri: state.uri,\n    onDismiss\n  }), [state.visible, connectToWalletService, walletServices, state.uri, onDismiss]);\n  const value = React.useMemo(() => {\n    if (connector) {\n      return { ...intermediateValue,\n        walletServices,\n        connectToWalletService,\n        connector: Object.assign(Object.create(connector), { ...connector,\n          connect: async opts => {\n            if (!walletServices.length) {\n              throw new Error('Mobile registry not yet ready.');\n            } else if (walletServicesError) {\n              throw walletServicesError;\n            }\n\n            const nextConnector = await createConnector(intermediateValue);\n            setConnector(nextConnector);\n            return nextConnector.connect(opts);\n          }\n        })\n      };\n    }\n\n    return { ...intermediateValue,\n      walletServices,\n      connectToWalletService,\n      connector\n    };\n  }, [intermediateValue, connectToWalletService, connector, state, setConnector, walletServices, walletServicesError]);\n  return React.createElement(WalletConnectContext.Provider, {\n    value: value\n  }, !!children && children, Platform.OS !== 'android' && renderQrcodeModal(modalProps));\n}","map":{"version":3,"sources":["/Users/ayushbhadauria/Desktop/onec-react-boilerplate/node_modules/@walletconnect/react-native-dapp/dist/providers/WalletConnectProvider.js"],"names":["WalletConnect","deepmerge","KeyValueStorage","React","Linking","Platform","useDeepCompareEffect","defaultRenderQrcodeModal","formatWalletServiceUrl","WalletConnectContext","useMobileRegistry","useWalletConnectContext","ConnectorEvents","defaultState","Object","freeze","visible","WalletConnectProvider","children","renderQrcodeModal","maybeRenderQrcodeModal","extras","error","walletServicesError","data","walletServices","state","setState","useState","parentContext","intermediateValue","useMemo","open","useCallback","uri","cb","OS","canOpenURL","openURL","Error","undefined","close","currentState","setTimeout","qrcodeModal","storageOptions","redirectUrl","createStorage","storage","setStorage","sessionStorageKey","rootStorageKey","walletServiceStorageKey","connectToWalletService","walletService","length","Promise","reject","maybeRedirectUrl","encodeURIComponent","connectionUrl","all","setItem","connector","setConnector","createConnector","shouldCreateConnector","params","_storageOptions","maybeExistingSession","maybeExistingWalletService","getItem","isResumable","removeItem","nextConnector","session","maybeThrowError","on","CONNECT","CALL_REQUEST_SENT","peerMeta","maybeShortName","name","toLowerCase","split","maybeMatchingServices","filter","metadata","shortName","detectedWalletService","url","SESSION_UPDATE","DISCONNECT","onDismiss","modalProps","value","assign","create","connect","opts","createElement","Provider"],"mappings":"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","sourcesContent":["import WalletConnect from '@walletconnect/client';\nimport deepmerge from 'deepmerge';\nimport { KeyValueStorage } from 'keyvaluestorage';\nimport * as React from 'react';\nimport { Linking, Platform } from 'react-native';\nimport useDeepCompareEffect from 'use-deep-compare-effect';\nimport { defaultRenderQrcodeModal, formatWalletServiceUrl } from '../constants';\nimport { WalletConnectContext } from '../contexts';\nimport { useMobileRegistry, useWalletConnectContext } from '../hooks';\nimport { ConnectorEvents, } from '../types';\nconst defaultState = Object.freeze({\n    visible: false,\n});\nexport default function WalletConnectProvider({ children, renderQrcodeModal: maybeRenderQrcodeModal, ...extras }) {\n    const { error: walletServicesError, data: walletServices } = useMobileRegistry();\n    const [state, setState] = React.useState(defaultState);\n    const parentContext = useWalletConnectContext();\n    const intermediateValue = React.useMemo(() => deepmerge(parentContext, extras), [parentContext, extras]);\n    const renderQrcodeModal = React.useMemo(() => (typeof maybeRenderQrcodeModal === 'function'\n        ? maybeRenderQrcodeModal\n        : defaultRenderQrcodeModal), [maybeRenderQrcodeModal]);\n    const open = React.useCallback(async (uri, cb) => {\n        if (Platform.OS === 'android') {\n            const canOpenURL = await Linking.canOpenURL(uri);\n            if (!canOpenURL) {\n                Linking.openURL('https://walletconnect.org/wallets');\n                throw new Error('No wallets found.');\n            }\n            await Linking.openURL(uri);\n        }\n        setState({\n            uri,\n            visible: true,\n            cb,\n        });\n        return undefined;\n    }, [setState]);\n    const close = React.useCallback(() => {\n        setState((currentState) => {\n            const { cb } = currentState;\n            setTimeout(() => typeof cb === 'function' && cb(), 0);\n            return {\n                uri: undefined,\n                visible: false,\n                cb: undefined,\n            };\n        });\n        return undefined;\n    }, [setState]);\n    const qrcodeModal = React.useMemo(() => ({\n        open,\n        close,\n    }), [open, close]);\n    const { storageOptions, redirectUrl } = intermediateValue;\n    const createStorage = React.useCallback((storageOptions) => {\n        return new KeyValueStorage(storageOptions);\n    }, []);\n    const [storage, setStorage] = React.useState(() => createStorage(storageOptions));\n    useDeepCompareEffect(() => {\n        setStorage(createStorage(storageOptions));\n    }, [setStorage, storageOptions]);\n    const sessionStorageKey = React.useMemo(() => `${storageOptions.rootStorageKey}:session`, [storageOptions]);\n    const walletServiceStorageKey = React.useMemo(() => `${storageOptions.rootStorageKey}:walletService`, [storageOptions]);\n    const connectToWalletService = React.useCallback(async (walletService, uri) => {\n        if (typeof uri !== 'string' || !uri.length) {\n            return Promise.reject(new Error('Invalid uri.'));\n        }\n        const maybeRedirectUrl = typeof redirectUrl === \"string\"\n            ? `&redirectUrl=${encodeURIComponent(redirectUrl)}`\n            : \"\";\n        const connectionUrl = `${formatWalletServiceUrl(walletService)}/wc?uri=${encodeURIComponent(uri)}${maybeRedirectUrl}`;\n        if (await Linking.canOpenURL(connectionUrl)) {\n            return await Promise.all([\n                storage.setItem(walletServiceStorageKey, walletService),\n                Linking.openURL(connectionUrl),\n            ]) && undefined;\n        }\n        return Promise.reject(new Error('Unable to open url.'));\n    }, [walletServiceStorageKey, storage, redirectUrl, state]);\n    const [connector, setConnector] = React.useState();\n    const createConnector = React.useCallback(async function shouldCreateConnector(params) {\n        const { storageOptions: _storageOptions, ...extras } = params;\n        const [maybeExistingSession, maybeExistingWalletService,] = await Promise.all([\n            await storage.getItem(sessionStorageKey),\n            await storage.getItem(walletServiceStorageKey),\n        ]);\n        const isResumable = !!maybeExistingSession && (Platform.OS === 'android' || !!maybeExistingWalletService);\n        if (!isResumable) {\n            await Promise.all([\n                storage.removeItem(sessionStorageKey),\n                storage.removeItem(walletServiceStorageKey),\n            ]);\n        }\n        const nextConnector = new WalletConnect({\n            session: isResumable ? maybeExistingSession : undefined,\n            qrcodeModal,\n            ...extras,\n        });\n        const maybeThrowError = (error) => {\n            if (error) {\n                throw error;\n            }\n        };\n        nextConnector.on(ConnectorEvents.CONNECT, async (error) => {\n            maybeThrowError(error);\n            await storage.setItem(sessionStorageKey, nextConnector.session);\n        });\n        nextConnector.on(ConnectorEvents.CALL_REQUEST_SENT, async (error) => {\n            maybeThrowError(error);\n            if (Platform.OS === 'android') {\n                const { peerMeta } = nextConnector;\n                if (!!peerMeta && typeof peerMeta === 'object') {\n                    const [maybeShortName] = `${peerMeta.name || ''}`.toLowerCase().split(/\\s+/);\n                    if (typeof maybeShortName === 'string' && !!maybeShortName.length) {\n                        const { walletServices } = parentContext;\n                        const [...maybeMatchingServices] = (walletServices || []).filter(({ metadata: { shortName } }) => {\n                            return `${shortName}`.toLowerCase() === maybeShortName;\n                        });\n                        if (maybeMatchingServices.length === 1) {\n                            const [detectedWalletService] = maybeMatchingServices;\n                            const url = formatWalletServiceUrl(detectedWalletService);\n                            if (await Linking.canOpenURL(url)) {\n                                return Linking.openURL(url);\n                            }\n                        }\n                    }\n                }\n                Linking.openURL('wc:');\n            }\n            else if (Platform.OS !== 'web') {\n                const walletService = await storage.getItem(walletServiceStorageKey);\n                if (!walletService) {\n                    return maybeThrowError(new Error('Cached WalletService not found.'));\n                }\n                const url = formatWalletServiceUrl(walletService);\n                return (await Linking.canOpenURL(url)) && Linking.openURL(url);\n            }\n        });\n        nextConnector.on(ConnectorEvents.SESSION_UPDATE, async (error) => {\n            maybeThrowError(error);\n            await storage.setItem(sessionStorageKey, nextConnector.session);\n        });\n        nextConnector.on(ConnectorEvents.DISCONNECT, async (error) => {\n            await Promise.all([\n                storage.setItem(sessionStorageKey, undefined),\n                storage.setItem(walletServiceStorageKey, undefined),\n            ]);\n            setConnector(await shouldCreateConnector(params));\n            maybeThrowError(error);\n        });\n        return nextConnector;\n    }, [\n        sessionStorageKey,\n        walletServiceStorageKey,\n        storage,\n        qrcodeModal,\n        setConnector,\n        parentContext,\n    ]);\n    useDeepCompareEffect(() => {\n        (async () => {\n            setConnector(await createConnector(intermediateValue));\n        })();\n    }, [setConnector, createConnector, intermediateValue]);\n    const onDismiss = React.useCallback(() => {\n        close();\n        (async () => {\n            setConnector(await createConnector(intermediateValue));\n        })();\n    }, [close, setConnector, createConnector, intermediateValue]);\n    const modalProps = React.useMemo(() => ({\n        connectToWalletService,\n        visible: state.visible,\n        walletServices,\n        uri: state.uri,\n        onDismiss,\n    }), [\n        state.visible,\n        connectToWalletService,\n        walletServices,\n        state.uri,\n        onDismiss,\n    ]);\n    const value = React.useMemo(() => {\n        if (connector) {\n            return {\n                ...intermediateValue,\n                walletServices,\n                connectToWalletService,\n                connector: Object.assign(Object.create(connector), {\n                    ...connector,\n                    connect: async (opts) => {\n                        if (!walletServices.length) {\n                            throw new Error('Mobile registry not yet ready.');\n                        }\n                        else if (walletServicesError) {\n                            throw walletServicesError;\n                        }\n                        const nextConnector = await createConnector(intermediateValue);\n                        setConnector(nextConnector);\n                        return nextConnector.connect(opts);\n                    },\n                }),\n            };\n        }\n        return {\n            ...intermediateValue,\n            walletServices,\n            connectToWalletService,\n            connector,\n        };\n    }, [\n        intermediateValue,\n        connectToWalletService,\n        connector,\n        state,\n        setConnector,\n        walletServices,\n        walletServicesError,\n    ]);\n    return (React.createElement(WalletConnectContext.Provider, { value: value },\n        !!children && children,\n        Platform.OS !== 'android' && renderQrcodeModal(modalProps)));\n}\n"]},"metadata":{},"sourceType":"module"}